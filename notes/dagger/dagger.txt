Dagger ->

1. @Inject ->

=> inject is used to make a class available for injecting.
=> We use inject annotation before constructor to make a class available
=> We use inject annotation to get object of any class.
	
2. Component ->

=> it's an interface.
=> We can declare methods by which we can get object. 
=> It's necessary to provide an @Inject Constructor or @Provides Method to get 
   the object of class
=> We don't need to provide any definition to those methods to return the object.
   It's autogenerated by compiler
=> We provide inject methods in component in which we provide the param of the 
   class in which we wanna get the object using @Inject.
=> We also declare the Modules at the declaration of class.


3. Modules ->

=> Module is a class in which we define the initialization of objects by using 
   @Provides or @Bind.
=> If any class which is a part of 3rd party so we can't change it's constructor
   (We can't add @Inject in the constructor declaration). So we provide a methods 
   where we define the initialization of that object.   

4. @Provides ->

=> If any class which is a part of 3rd party so we can't change it's constructor
   (We can't add @Inject before the constructor declaration). So we provide a 
   methods by using @Provides where we define the initialization of that object.
   
5. @Binds ->

=> If we need an object of 3rd party interface. 
=> In that case first of all we have to create a concrete class which implements
   that interface.
=> Now we can provide the object of that interface by creating a method in 
   module using @Binds.
=> In that method we don't need to provide definition we can just declare
   a method using @BInds annotation and providing the Concrete class's object
   as parameter.
   Ex -> @Binds fun (engine:PetrolEngine):Engine
   
6. Passing value in ->
OPTION A->

=> We can create a class's constructor which takes a param.
=> We can provide values by creating a Module which takes params in it's 
   constructor.
=> Now we can define a @Provides method to provide that value to the specific
   method/object.
=> Now we can pass the value in component by using builder.
=> Now we will get a module methode in which we can pass the object of 
   related Module in which we can pass the values.
   
OPTION B->

=> Without passing value in Module's constructor.
=> We can use @Component.Builder.
=> We can define a Builder interface in Component.
=> We can use @BindInstances to pass arguments.
=> In this case we just need to define a Builder and we can provide declaration
   for build method which return Component object. And we can use @BindInstances
   to provide arguments.
   

7. Component.Builder ->
=> Builder is an interface.
=> In case if we wanna pass arguments/parameter to get any object. We can use 
   Builder.

   
8. BindInstances ->
=> To pass a parameter in @Injected class's constructor we use @BindInstances


9. @Named ->
=> In case of passing more than one arguments/params we can use @Named to 
   differencation between them.
   
   
10 @Singleton ->

=> Without using @Singleton we get the numbere of different object how many we
   declare the @Inject (@Inject car:Car)
=> In the case of Retrofit we need same object everyTime we don't need new
   object everyTime.   

=> If we want to constraint a class to create only one object in that case we
   use @Singleton annotation.
=> Singleton is only constraint to the Component object.
   Means if we create more than one object of Component then we'll get different
   object of Injected class.
=> But if we create more than one object using @Inject in the scope of same
   Component we'll get same Object.
=> If we create more than one object using @Inject in the different scope of 
   Component in that case we'll get different object.

=> If we create 2 object of Component and we get injected object from both
   we'll get different object.
=> If we create 1 object of Component and we get injected object from this 
   then we'll get same object.

=> We can use @Singleton with class signature/declaration or with @Provides method   
=> We also have to add @Singleton annotation in Component interface.


11. Custom Scope ->

=> There is nothing like custom scope.
=> It depends on the developer that how he use Scope.
=> If we create an objet of component in Activity then it's scope will be till
   activity.
=> If we want an object which has component for whole the app. We'll have to 
   create an object in Application level.


12. Component Dependency ->

=> If one component use an object which comes in the scope of other component
   then we  have to declare that component in it's declaration as a 
   dependency.
=> We can't use the scope with annotating same annotation.
=> Like if 2 appcomponent and activityComponent both using @Singleton.
=> We need to create a new scope like @PerActivity scope for Activity  

13. Factory ->
    
=> Factory is an interface which is a replacement of Builder.
=> in Factory method we use "create" method instead of build.
=> Difference btw builder and factory is that we have to pass params in 
   create method but in Builder we provide methods to set pass values.

14. SubComponent ->

=> We provide the SubComponent object from Parent Component.
=> In the case of Builder/Factory we provide Builder/Factory object.
=> Other thing like Builder/Factory are same as in Component   




   
   
   
   
   
   
   
   
   
   
   
   
   